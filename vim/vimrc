" vim: set foldmethod=marker:
"----- base setting -----
"base settings{{{
"Bundle{{{
set nocompatible
filetype off

set rtp+=~/.vim/bundle/Vundle.vim
call vundle#rc()

" bundle
Bundle 'gmarik/Vundle.vim'
Bundle 'Align'
Bundle 'taglist.vim'
Bundle 'sudo.vim'
Bundle 'vimwiki'

if v:version > 700
Bundle 'Shougo/neocomplcache'
Bundle 'Shougo/unite.vim'
Bundle 'Shougo/vimfiler'
Bundle 'Shougo/vimproc'
Bundle 'Shougo/vimshell'
endif

Bundle 'thinca/vim-quickrun'
Bundle 'thinca/vim-ref'
Bundle 'mattn/emmet-vim'
Bundle 'yuratomo/w3m.vim'
Bundle 'scrooloose/syntastic'
Bundle 'soh335/vim-symfony'
"Bundle 'mattn/gist-vim'
Bundle 'mattn/webapi-vim'
Bundle 'h1mesuke/unite-outline'
Bundle 'tpope/vim-surround'
Bundle 'nise-nabe/unite-openpne'
Bundle 'tpope/vim-fugitive'
Bundle 'Simple-Javascript-Indenter'
"Bundle 'jelera/vim-javascript-syntax'
Bundle 'project.tar.gz'
Bundle 'rking/ag.vim'
Bundle 'superbrothers/vim-vimperator'
"Bundle 'hallettj/jslint.vim'
Bundle 'tpope/vim-endwise'
Bundle 'tpope/vim-rails'
"Bundle 'comeonly/php.vim-html-enhanced'
Bundle 'soramugi/auto-ctags.vim'
Bundle 'slim-template/vim-slim'

syntax on
filetype plugin indent on
"}}}
"基本設定{{{
let OSTYPE = system('uname')
if OSTYPE == "Darwin\n"
  let $PATH = $PATH.':/usr/local/bin/'
  if exists('+macmeta')
    set macmeta
  endif
endif
" encording
set encoding=utf-8
set termencoding=utf-8
set fileencoding=utf-8
set fileencodings=ucs-bom,iso-2022-jp-3,iso-2022-jp,eucjp-ms,euc-jisx0213,euc-jp,utf-8,sjis,cp932
"set fileencodings=utf-8
set clipboard=unnamed,autoselect
set iminsert=0
set imsearch=0
"set imdisable
set iskeyword=@,48-57,_,128-167,224-235
set backspace=indent,eol,start
set visualbell t_vb=

set incsearch
set ignorecase   " 検索時に大文字小文字を無視
set smartcase    " 大文字小文字の両方が含まれている場合は大文字小文字を区別
set wrapscan        " 検索時にファイルの最後まで行ったら最初に戻る (nowrapscan:戻らない)
"set grepprg=ack\ -a
set grepformat=%f:%l:%m,%f:%l%m,%f\ \ %l%m,%f
set grepprg=grep\ -nH
set hlsearch

set tabstop=2        " タブの画面上での幅
set expandtab      " タブをスペースに展開しない
set shiftwidth=2    " autoindentなどの時のタブ幅
set softtabstop=2
set smartindent
set autoindent
set showmatch        " 括弧入力時に対応する括弧を表示 (noshowmatch:表示しない)

"viminfo // see :help 23.1
"set viminfo='1000,f1,<500,s100
"set viminfo+=n~/tmp/viminfo
"set backspace=2    " バックスペースでインデントや改行を削除できるようにする
"set showmode
set wildmenu        " コマンドライン補完するときに強化されたものを使う(参照 :help wildmenu)
set wildmode=list:full,full " コマンドライン補完をシェルっぽくする
"set formatoptions+=mM   " テキスト挿入中の自動折り返しを日本語に対応させる
"自動折り返し切りたいのだが...
"set textwidth=0
set formatoptions=q
set number
set list        " タブや改行を表示 (list:表示)
set listchars=tab:>-,extends:<,trail:-,eol:$ " どの文字でタブや改行を表示するかを設定
set wrap          " 長い行を折り返して表示
set noruler
set cmdheight=2    " コマンドラインの高さ
"set showcmd        " コマンドをステータス行に表示
"set title          " タイトルを表示
" statusline
set laststatus=2  " 常にステータス行を表示
set statusline=path:%F%m%r%h%w%=%L[enc:%{&fileencoding}][ff:%{&ff}]
" tabline
set showtabline=2

set autoread     "他で書き換えられた場合、自動で読みなおす
set noswapfile
set nobackup     " バックアップファイルを作成しない
set ambiwidth=double
"set formatexpr=Format_Japanese()
set helplang=ja
set history=50
set splitbelow
set splitright
set virtualedit+=block " 矩形選択で行末を超えてブロックを選択できるようにする
set foldmethod=marker

autocmd BufReadPost *.txt,*.memo |
  \ set foldmethod=indent |
set foldopen=hor,search,insert,jump,tag
"set foldclose=all
set modeline

"undo file
set noundofile
"ctags
"set tags+=tags
set tags+=./tags,../../tags
"ファイル読み込み時にhighlightしない
noh
"}}}
" colorscheme{{{
if filereadable(expand("~/.vim/colors/mycolor.vim"))
  colorscheme mycolor
else
  colorscheme elflord
endif
"}}}
"}}}
"----- keymapping -----
"keymap{{{
"normal-mode{{{
"カーソルを表示行で移動する。物理行移動は<C-n>,<C-p>
nnoremap j gj
nnoremap k gk
nnoremap <Down> gj
nnoremap <Up>   gk
nnoremap <C-h> hx
nnoremap <S-h> 0
nnoremap <S-l> $
nnoremap <C-g> gT
nnoremap <C-c> gt
" 行頭/行末へ移動
"nnoremap <C-a> 0
nnoremap <C-e> <S-$>
" Ctrl+Nで次のバッファを表示
nnoremap <C-N>   :bnext<CR>
" Ctrl+Pで前のバッファを表示
nnoremap <C-P>   :bprevious<CR>
nnoremap <C-j> <C-]>
nnoremap g<C-j> g<C-]>
" tmuxのプレフィックスとかぶるので
nnoremap <C-f> <nop>
" 数値を増やす
nnoremap <S-a> <C-a>
nnoremap <S-x> <C-x>

nnoremap <space>w :w<CR>
nnoremap <space>q :q<CR>
" タブを開く
"nnoremap t :tabe<space>
" vimrcを編集・読み込み
nnoremap .. :tabe ~/.vimrc<CR>
nnoremap ,, :source ~/.vimrc<CR>
nnoremap <silent>;w :set nowrap!<CR>
nnoremap <silent>;n :set nonumber!<CR>
nnoremap <silent>;a :append!<CR>
nnoremap <silent>;l :noh<CR>
nnoremap -- 78i-<esc>o<esc>
"folding {{{
"noremap [space] <nop>
"nmap <space> [space]
nnoremap <space>j zj
nnoremap <space>k zk
nnoremap <space>n ]z
nnoremap <space>p [z
nnoremap <space>h zc
nnoremap <space>l zo
nnoremap <space><space> za
nnoremap <space>a za
nnoremap <space>m zM
nnoremap <space>i zMzv
nnoremap <space>r zR
nnoremap <space>f zf
nnoremap zd <nop>
nnoremap zD <nop>
nnoremap zE <nop>
"}}}
"plugin {{{
nnoremap cs :Csvhl<space>
"unite
nnoremap <silent> ,y :<C-u>Unite history/yank<CR>
"snipet
noremap es :<C-u>NeoComplCacheEditSnippets<CR>
"firefox
nnoremap ,f :!open -a firefox % >/dev/null<CR>
" alc
nnoremap E :Ref webdict<space>
" Gist
nnoremap gl :Gist -l<CR>
if OSTYPE == "Darwin\n"
  nnoremap <space>/ g/
endif
nnoremap pne :Unite pne/
nnoremap <Leader>ag :Ag<space>
"}}}
"}}}
"insert-mode{{{
inoremap <C-j> <Esc>
inoremap <C-k> <CR>
inoremap {} {}<Left>
inoremap [] []<Left>
inoremap () ()<Left>
inoremap <> <><Left>
inoremap "" ""<Left>
inoremap '' ''<Left>
inoremap `` ``<Left>
inoremap /* /*  */<Left><Left><Left>
inoremap <C-l> ->
inoremap <M-l> =>

"inoremap <silent> <ESC> <ESC>:set iminsert=0<CR>
"inoremap <C-k> <CR>
"snipet
"imap <C-k> <Plug>(neocomplcache_snippets_expand)
"}}}
"commandline-mode{{{
cnoremap <C-A> <HOME>
cnoremap <C-e> <End>
cnoremap <C-k> <CR>
cnoremap <C-j> <ESC>
"}}}
"visual-mode{{{
vnoremap <C-j> <esc>
vnoremap <S-l> $
vnoremap <S-h> 0
"行末に挿入
vnoremap <S-a> $<S-a>
vnoremap * "vy/\V<C-r>=substitute(escape(@v,'\/'),"\n",'\\n','g')<CR><CR>
"}}}
"}}}
"----- other setting -----
"other setting{{{
"ファイルの閉じた場所を記憶{{{
autocmd BufReadPost *
    \ if line("'\"") > 1 && line("'\"") <= line("$") |
    \   exe "normal! g`\"" |
    \ endif
"}}}
" csvh{{{
function! CSVH(x)
    execute 'match Keyword /^\([^,]*,\)\{'.a:x.'}\zs[^,]*/'
    execute 'normal ^'.a:x
endfunction
command! -nargs=1 Csvhl :call CSVH(<args>)

autocmd BufNewFile,BufRead *.csv set nowrap
"}}}
"php関連{{{
let php_folding = 1
let php_htmlInStrings = 1
"let php_sql_query = 1
"let php_noShortTags = 1  "autoindentされなくなるので却下
" PHP Lint
function! PHPLint()
  let result = system( &ft . ' -l ' . bufname(""))
  echo result
endfunction
nmap ,l :call PHPLint()<CR>
" ファイルタイプの変更()
autocmd BufReadPost,BufNewFile *.php nnoremap <buffer> HH :set ft=html<CR>
autocmd BufReadPost,BufNewFile *.php nnoremap <buffer> PH :set ft=php<CR>
autocmd BufReadPost,BufNewFile *.php inoremap <buffer> $thi $this->
autocmd BufReadPost,BufNewFile *.php inoremap <buffer>?? ?php  ?<Left><Left>
autocmd BufRead,BufNewFile *.php.sample setfiletype php
"}}}
" html/xml{{{
" 閉じタグの補完
augroup MyXML
  autocmd!
  autocmd Filetype xml inoremap <buffer> </ </<C-x><C-o>
  autocmd Filetype html inoremap <buffer> </ </<C-x><C-o>
"  autocmd Filetype php inoremap <buffer> </ </<C-x><C-o>
augroup END
" タグ対応箇所に%で飛ぶ
source $VIMRUNTIME/macros/matchit.vim
" xmlファイル自動整形(要xmllint)
au FileType xml :silent 1,$!xmllint --format --recover - 2>/dev/null
"}}}
" ruby {{{
autocmd BufReadPost,BufNewFile *.erb inoremap <buffer>%% <%  %><Left><Left><Left>
autocmd BufReadPost,BufNewFile *.erb inoremap <buffer>%= <%=  %><Left><Left><Left>
autocmd BufReadPost,BufNewFile *.rb  inoremap <buffer>{} {  }<Left><Left>
autocmd BufReadPost,BufNewFile *.slim set filetype=slim
"}}}

" tabWrapper{{{
function! InsertTabWrapper()
  if pumvisible()
      return "\<c-n>"
  endif
  let col = col('.') - 1
  if !col || getline('.')[col - 1] !~ '\k\|<\|/'
      return "\<tab>"
  "elseif exists('&omnifunc') && &omnifunc == ''
  "    return "\<c-n>"
  else
      return "\<c-x>\<c-o>"
  endif
endfunction
inoremap <tab> <c-r>=InsertTabWrapper()<cr>
"}}}
" 行のURLを開く{{{
function! HandleURI()
  let s:uri = matchstr(getline("."), '[a-z]*:\/\/[^ >,;:]*')
  if s:uri != ""
    echo s:uri
    exec "silent :w !open \"" . s:uri . "\""
  else
    echo "No URI found in line."
  endif
endfunction
map <Leader>f :call HandleURI()<CR>
"}}}
" javascript{{{
" この設定入れるとshiftwidthを1にしてインデントしてくれる
"let g:SimpleJsIndenter_BriefMode = 2
"" この設定入れるとswitchのインデントがいくらかマシに
"let g:SimpleJsIndenter_CaseIndentLevel = -1
function! JavaScriptFold()  " {{{
    setl foldmethod=syntax
    setl foldlevelstart=1
    syn region foldBraces start=/{/ end=/}/ transparent fold keepend extend

    function! FoldText()
        return substitute(getline(v:foldstart), '{.*', '{...}', '')
    endfunction
    setl foldtext=FoldText()
endfunction  "}}}
au FileType javascript call JavaScriptFold()
au FileType javascript setl fen
autocmd FileType javascript setl autoindent
autocmd FileType javascript setl smartindent
autocmd FileType javascript setl tabstop=4 expandtab shiftwidth=4 softtabstop=4
"let g:syntastic_javascript_checkers=['gjslint']
"}}}
let g:auto_ctags_bin_path = '/usr/local/bin/ctags'
autocmd FileType help noremap <buffer><silent> q :bd<CR>
command! Utf :set fenc=utf8<CR>
autocmd BufRead ~/.vimperator/conf/* setl ft=vimperator
" ローカル辞書をひく(for mac){{{
if OSTYPE == "Darwin\n"
  function! DictSearch(...)
    let text = join(a:000, ' ')
    exec 'silent :w !open dict://"'.text.'"'
  endfunction
  command! -nargs=+ Dict :call DictSearch("<args>")
  nnoremap ,d :Dict<space>
endif
"}}}
"}}}
"----- plugin setting -----
"plugins{{{
"VimFiler{{{
nnoremap <silent>F :VimFiler -buffer-name=explorer -simple -split  -winwidth=25 -toggle -no-quit -auto-cd<CR>
autocmd FileType vimfiler nmap s <Plug>(vimfiler_toggle_mark_current_line)
autocmd FileType vimfiler setlocal nonumber
if OSTYPE == "Darwin\n"
  let g:vimfiler_safe_mode_by_default = 0
  let g:vimfiler_as_default_explorer = 1
  let g:vimfiler_min_filename_width = 10
  "let g:vimfiler_edit_action = 'tabopen'
  "キャッシュはramに保存
  let g:vimfiler_data_directory = '/tmp/.vimfiler'
  "autocmd FileType vimfiler :map O <Plug>(vimfiler_double_click) 
"}}}
"netrw(FileExplorer){{{
elseif OSTYPE == "Linux\n"
  let g:netrw_preview   = 1  " ファイルのプレビューを垂直分割で開く
  let g:netrw_liststyle = 3  " netrwは常にtree view
  let g:netrw_altv = 1  " 'v'でファイルを開くときは右側に開く
  let g:netrw_alto = 1 " 'o'でファイルを開くときは下側に開く
  let g:netrw_browsex_viewer = 'xdg-open' " xでファイルを開く
  let g:netrw_winsize = 80
endif
"}}}
"Align{{{
let g:Align_xstrlen=3
"}}}
" vim-Ref{{{
" phpmanual
let g:ref_phpmanual_path = $HOME.'/.vim/man/php-chunked-xhtml'
autocmd FileType ref-phpmanual nnoremap <buffer><silent> q :bd<CR>
"let g:ref_phpmanual_cmd = 'w3m -dump %s'
"" php補完ファイル置き場
""autocmd FileType php :set dictionary=~/.vim/dict/php_func.dict
nnoremap ,p :Ref<space>phpmanual<space>
" webdictサイトの設定
let g:ref_source_webdict_sites = {
\   'wiki': { 'url': 'http://ja.wikipedia.org/wiki/%s' },
\   'alc': { 'url': 'http://eow.alc.co.jp/%s' },
\   'oxford': { 'url': 'http://www.oxforddictionaries.com/definition/english/%s' },
\ }
" 一度開いたページをキャッシュ
let g:ref_source_webdict_use_cache = 1
let g:ref_cache_dir = '/tmp/vimref'
let g:ref_use_vimproc = 1
" デフォルトサイト
let g:ref_source_webdict_sites.default = 'alc'
" 出力に対するフィルタ。最初の数行を削除
function! g:ref_source_webdict_sites.alc.filter(output)
  let output=a:output
  "よみがなを削除
  let output=substitute(output, '｛\([^｝]\)*｝', '', 'g')
  let output=substitute(output, '◆', ' * ', 'g')
  let output=substitute(output, '⇒', '=>', 'g')
  ""》】）。"以外のマルチバイト文字で終わって"《【（・•"以外のマルチバイト文字で始まる文の改行コードを削除
  let output=substitute(output, '\([^\x01-\x7E^》^】^）^。]\)\n\s\+\([^\x01-\x7E^《^【^（^・^•]\)', '\1\2', 'g')
  let output=substitute(output, '（','(','g')
  let output=substitute(output, '）',')','g')
  " リストになっているタイトル文字列を==で囲む
  let output=substitute(output, '•\(\s[a-zA-Z]\+[a-zA-Z -,.]*\)', '\n==\1 ==', 'g')
  let output=substitute(output, '・\([a-zA-Z ]\+\)\n\s*\([a-zA-Z ]\+\.\)', '\1 \2', 'g')
  let output=substitute(output, '\(\.\)\(\s:\)', '\1\n        \2', 'g')

  return join(split(output, "\n")[30:], "\n")
endfunction
function! g:ref_source_webdict_sites.wiki.filter(output)
  return join(split(a:output, "\n")[8 :], "\n")
endfunction
function! g:ref_source_webdict_sites.oxford.filter(output)
  return join(split(a:output, "\n")[208 :], "\n")
endfunction
nnoremap ,e :Ref webdict alc<space>
nnoremap ,o :Ref webdict oxford<space>
autocmd FileType ref-webdict nnoremap <buffer><silent> q :bd<CR>
"}}}
" taglist{{{
let Tlist_Show_One_File = 1
let Tlist_Use_Right_Window = 1
let Tlist_Exit_OnlyWindow = 1
"}}}
" zen-codung{{{
let g:user_emmet_expandabbr_key = '<C-@>'
let g:user_emmet_leader_key = '<C-i>'
"}}}
" unite.vim{{{
"データはramに保存
if v:version > 700
let g:unite_data_directory = '/tmp/.unite'
let g:unite_source_history_yank_enable =1  "history/yankの有効化
" 入力モードで開始する
let g:unite_enable_start_insert=1
" バッファ一覧
noremap <C-U><C-B> :Unite buffer<CR>
" ファイル一覧
noremap <C-U>f :UniteWithBufferDir -buffer-name=files file<CR>
" 最近使ったファイルの一覧
noremap <C-U><C-R> :Unite file_mru<CR>
" レジスタ一覧
noremap <C-U>y :Unite -buffer-name=register register<CR>
" function
nnoremap f :Unite outline<CR>
nnoremap <C-u>f :Unite function<CR>
endif
"}}}
" vimshell{{{
nnoremap <silent> vs :VimShell<CR>
nnoremap <silent> vp :VimShellPop<CR>
autocmd FileType vimshell setlocal nonumber
"}}}
"neocomplcache{{{
if v:version > 700
  let g:neocomplcache_enable_at_startup = 1           " 起動時に有効化
  let g:NeoComplCache_SmartCase = 1                   " Use smartcase.
  let g:NeoComplCache_EnableCamelCaseCompletion = 1   " Use camel case completion.
  let g:NeoComplCache_EnableUnderbarCompletion = 1    " Use underbar completion.
  let g:NeoComplCache_MinSyntaxLength = 3             " Set minimum syntax keyword length.
  let g:NeoComplCache_ManualCompletionStartLength = 0 " Set manual completion length.
  let g:neocomplcache_temporary_dir = '/tmp/.neocon'  "RamDiskをキャッシュディレクトリに設定
  "補完するためのキーワードパターンを指定
  if !exists('g:neocomplcache_keyword_patterns')
    let g:neocomplcache_keyword_patterns = {}
  endif
  let g:neocomplcache_keyword_patterns['default'] = '\h\w*' "日本語を補完候補として取得しないようにする
  let g:NeoComplCache_CachingPercentInStatusline = 1 " Print caching percent in statusline.

  "シンタックス補完を無効に
  let g:neocomplcache_plugin_disable = {
    \ 'syntax_complete' : 1,
    \ }

  "ファイルタイプの関連付け
  if !exists('g:neocomplcache_same_filetype_lists')
    let g:neocomplcache_same_filetype_lists = {}
  endif
  "let g:neocomplcache_same_filetype_lists['ctp'] = 'php'
  "let g:neocomplcache_same_filetype_lists['twig'] = 'html'

  "ディクショナリ補完
  "ファイルタイプごとの辞書ファイルの場所
  "let g:neocomplcache_dictionary_filetype_lists = {
  "  \ 'default' : '',
  "  \ 'php' : $HOME . '/.vim/dict/php_func.dict',
  "  \ 'vimshell' : $HOME . '/.vimshell/command-history',
  "  \ }
endif
"}}}
" QFixMemo{{{
" デフォルトの保存先
let qfixmemo_dir = '~/.vim/qfix'
" メモのエンコーディング
let qfixmemo_fileencoding = 'utf-8'
" メモの改行コード
let qfixmemo_fileformat = 'unix'
" メモのファイルタイプは自動判別
let qfixmemo_filetype = ''
" 新規メモ用のテンプレート
let qfixmemo_template = [
  \'%TITLE%  %TAG%',
  \""
\]
let QFixHowm_MenuPreview = 1
"}}}
" snippet{{{
smap <C-k> <Plug>(neocomplcache_snippets_expand)
"}}}
" vimwiki {{{
let g:vimwiki_folding="syntax"
let g:vimwiki_hl_cb_checked=1
let g:vimwiki_list=[{'path':'~/.vim/vimwiki/'}]
nmap <C-h> <Plug>VimwikiGoBackLink
nmap <CR> <Plug>VimwikiFollowLink
"}}}
" vimproject{{{
let g:proj_flags = "imstc"
nmap P <plug>ToggleProject
if getcwd() != $HOME
  if filereadable(getcwd(). '/.vimproject')
   "au BufReadPost * Project .vimproject
   "au BufNewFile * Project .vimproject
  endif
endif
"}}}
" w3m {{{
if executable('w3m')
  autocmd! FileType w3m setlocal nonumber
  autocmd! FileType w3m nnoremap <buffer> q :bdelete<CR>
endif
"}}}
"}}}

" ローカル設定の読み込み
if filereadable(expand('~/.vim/vimrc.local'))
  source ~/.vim/vimrc.local
endif
if has('gui_running')
  nnoremap ¥ \
  inoremap ¥ \
  cnoremap ¥ \
endif
